// VentasPet - Sistema de Testing y Validaci√≥n de Rendimiento
// Implementa tests automatizados, lighthouse integration y validaci√≥n de optimizaciones

console.log('üß™ Cargando Performance Testing Suite...');

window.PerformanceTesting = {
    // Configuraci√≥n de testing
    config: {
        // Umbrales de rendimiento (milisegundos)
        thresholds: {
            // Core Web Vitals
            lcp: { good: 2500, poor: 4000 },
            fid: { good: 100, poor: 300 },
            cls: { good: 0.1, poor: 0.25 },
            
            // M√©tricas personalizadas
            pageLoad: { good: 3000, poor: 5000 },
            domReady: { good: 1500, poor: 3000 },
            firstPaint: { good: 1000, poor: 2000 },
            
            // API performance
            apiResponse: { good: 500, poor: 2000 },
            
            // Bundle sizes (KB)
            bundleSize: { good: 500, poor: 1000 },
            imageSize: { good: 200, poor: 500 }
        },
        
        // Configuraci√≥n de tests
        testConfig: {
            iterations: 3,
            warmupIterations: 1,
            cooldownDelay: 1000, // ms entre tests
            timeoutMs: 30000
        },
        
        // URLs para testing
        testUrls: [
            { name: 'Home', url: '/', weight: 1.0 },
            { name: 'Products', url: '/products', weight: 0.8 },
            { name: 'Cart', url: '/cart', weight: 0.6 },
            { name: 'Checkout', url: '/checkout', weight: 0.4 }
        ]
    },
    
    // Resultados de tests
    testResults: {
        baseline: null,
        current: null,
        history: []
    },
    
    // Estado del testing
    isRunning: false,
    currentTest: null,
    
    init() {
        console.log('üöÄ Inicializando Performance Testing Suite...');
        
        // Configurar listeners para m√©tricas autom√°ticas
        this.setupAutomaticTesting();
        
        // Configurar reportes autom√°ticos
        this.setupAutomaticReporting();
        
        // Cargar baseline si existe
        this.loadBaseline();
        
        return this;
    },
    
    // ========= TESTS PRINCIPALES =========
    
    // Ejecutar suite completa de tests
    async runFullTestSuite() {\n        if (this.isRunning) {\n            console.warn('‚ö†Ô∏è Tests ya en ejecuci√≥n');\n            return;\n        }\n        \n        console.log('üß™ Iniciando suite completa de tests de rendimiento...');\n        this.isRunning = true;\n        \n        const startTime = Date.now();\n        const results = {\n            timestamp: new Date().toISOString(),\n            userAgent: navigator.userAgent,\n            url: window.location.href,\n            viewport: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            },\n            connection: this._getConnectionInfo(),\n            tests: {},\n            summary: {}\n        };\n        \n        try {\n            // Tests de m√©tricas b√°sicas\n            console.log('üìä Ejecutando tests de m√©tricas b√°sicas...');\n            results.tests.basicMetrics = await this.testBasicMetrics();\n            \n            // Tests de Core Web Vitals\n            console.log('üéØ Ejecutando tests de Core Web Vitals...');\n            results.tests.coreWebVitals = await this.testCoreWebVitals();\n            \n            // Tests de cache y almacenamiento\n            console.log('üíæ Ejecutando tests de cache...');\n            results.tests.cachePerformance = await this.testCachePerformance();\n            \n            // Tests de API\n            console.log('üì° Ejecutando tests de API...');\n            results.tests.apiPerformance = await this.testApiPerformance();\n            \n            // Tests de im√°genes\n            console.log('üñºÔ∏è Ejecutando tests de im√°genes...');\n            results.tests.imageOptimization = await this.testImageOptimization();\n            \n            // Tests de componentes React\n            console.log('‚öõÔ∏è Ejecutando tests de React...');\n            results.tests.reactPerformance = await this.testReactPerformance();\n            \n            // Generar resumen\n            results.summary = this._generateSummary(results.tests);\n            \n            // Guardar resultados\n            this.testResults.current = results;\n            this._saveResults(results);\n            \n            const duration = Date.now() - startTime;\n            console.log(`‚úÖ Suite de tests completada en ${duration}ms`);\n            \n            // Mostrar resumen\n            this.showTestReport();\n            \n            return results;\n            \n        } catch (error) {\n            console.error('‚ùå Error ejecutando tests:', error);\n            throw error;\n        } finally {\n            this.isRunning = false;\n        }\n    },\n    \n    // Test de m√©tricas b√°sicas\n    async testBasicMetrics() {\n        const results = {};\n        \n        // Navigation Timing API\n        const navigationEntry = performance.getEntriesByType('navigation')[0];\n        if (navigationEntry) {\n            results.pageLoadTime = navigationEntry.loadEventEnd - navigationEntry.navigationStart;\n            results.domContentLoaded = navigationEntry.domContentLoadedEventEnd - navigationEntry.navigationStart;\n            results.firstPaint = this._getFirstPaint();\n            results.domInteractive = navigationEntry.domInteractive - navigationEntry.navigationStart;\n            results.dnsTime = navigationEntry.domainLookupEnd - navigationEntry.domainLookupStart;\n            results.connectTime = navigationEntry.connectEnd - navigationEntry.connectStart;\n            results.serverResponseTime = navigationEntry.responseEnd - navigationEntry.requestStart;\n        }\n        \n        // Resource timing\n        const resources = performance.getEntriesByType('resource');\n        results.totalResources = resources.length;\n        results.totalTransferSize = resources.reduce((sum, r) => sum + (r.transferSize || 0), 0);\n        results.averageResourceTime = resources.reduce((sum, r) => sum + r.duration, 0) / resources.length;\n        \n        // Memory usage (si est√° disponible)\n        if (performance.memory) {\n            results.memoryUsage = {\n                used: performance.memory.usedJSHeapSize,\n                total: performance.memory.totalJSHeapSize,\n                limit: performance.memory.jsHeapSizeLimit\n            };\n        }\n        \n        return this._evaluateResults(results, {\n            pageLoadTime: this.config.thresholds.pageLoad,\n            domContentLoaded: this.config.thresholds.domReady,\n            firstPaint: this.config.thresholds.firstPaint\n        });\n    },\n    \n    // Test de Core Web Vitals\n    async testCoreWebVitals() {\n        const results = {};\n        \n        // Obtener m√©tricas del PerformanceAnalyzer si est√° disponible\n        if (window.PerformanceAnalyzer && window.PerformanceAnalyzer.metrics) {\n            const cwv = window.PerformanceAnalyzer.metrics.coreWebVitals;\n            \n            if (cwv.lcp) results.lcp = cwv.lcp;\n            if (cwv.fid) results.fid = cwv.fid;\n            if (cwv.cls) results.cls = cwv.cls;\n        }\n        \n        // Medir FCP manualmente\n        results.fcp = this._getFirstContentfulPaint();\n        \n        // Calcular CLS manualmente si no est√° disponible\n        if (!results.cls) {\n            results.cls = await this._measureCLS();\n        }\n        \n        return this._evaluateResults(results, {\n            lcp: this.config.thresholds.lcp,\n            fid: this.config.thresholds.fid,\n            cls: this.config.thresholds.cls\n        });\n    },\n    \n    // Test de rendimiento de cache\n    async testCachePerformance() {\n        const results = {};\n        \n        if (window.CacheManager) {\n            const stats = window.CacheManager.getStats();\n            results.cacheStats = stats;\n            results.hitRate = parseFloat(stats.hitRate) || 0;\n            results.totalKeys = stats.totalKeys;\n            results.cacheSize = stats.formattedSize;\n        }\n        \n        // Test de velocidad de cache\n        const cacheSpeedTest = await this._testCacheSpeed();\n        results.cacheSpeed = cacheSpeedTest;\n        \n        return this._evaluateResults(results, {\n            hitRate: { good: 70, poor: 30 }, // porcentaje\n            cacheSpeed: { good: 10, poor: 50 } // ms\n        });\n    },\n    \n    // Test de rendimiento de API\n    async testApiPerformance() {\n        const results = {};\n        \n        if (window.ApiOptimizer) {\n            const stats = window.ApiOptimizer.getStats();\n            results.apiStats = stats;\n            results.averageResponseTime = parseFloat(stats.averageResponseTime) || 0;\n            results.hitRate = parseFloat(stats.hitRate) || 0;\n            results.failureRate = (stats.failedRequests / stats.totalRequests * 100) || 0;\n        }\n        \n        // Test de endpoints cr√≠ticos\n        const endpointTests = await this._testCriticalEndpoints();\n        results.endpointTests = endpointTests;\n        \n        return this._evaluateResults(results, {\n            averageResponseTime: this.config.thresholds.apiResponse,\n            hitRate: { good: 60, poor: 20 },\n            failureRate: { good: 5, poor: 15 }\n        });\n    },\n    \n    // Test de optimizaci√≥n de im√°genes\n    async testImageOptimization() {\n        const results = {};\n        \n        if (window.ImageOptimizer) {\n            const stats = window.ImageOptimizer.getStats();\n            results.imageStats = stats;\n            results.compressionRatio = parseFloat(stats.averageCompressionPercent) || 0;\n            results.lazyLoadedImages = stats.lazyLoadedImages;\n            results.webpSupported = stats.webpSupported;\n        }\n        \n        // Analizar im√°genes en p√°gina\n        const imageAnalysis = this._analyzePageImages();\n        results.imageAnalysis = imageAnalysis;\n        \n        return this._evaluateResults(results, {\n            compressionRatio: { good: 70, poor: 90 }, // menor es mejor\n            averageImageSize: this.config.thresholds.imageSize\n        });\n    },\n    \n    // Test de rendimiento de React\n    async testReactPerformance() {\n        const results = {};\n        \n        // Contar componentes y renders\n        results.componentCount = this._countReactComponents();\n        \n        // Medir tiempo de render\n        const renderTime = await this._measureRenderTime();\n        results.averageRenderTime = renderTime;\n        \n        // Detectar re-renders innecesarios\n        const rerenderAnalysis = this._analyzeReRenders();\n        results.rerenderAnalysis = rerenderAnalysis;\n        \n        return this._evaluateResults(results, {\n            averageRenderTime: { good: 16, poor: 50 }, // 60fps = 16ms por frame\n            unnecessaryRerenders: { good: 5, poor: 20 }\n        });\n    },\n    \n    // ========= M√âTODOS DE MEDICI√ìN =========\n    \n    // Obtener First Paint\n    _getFirstPaint() {\n        const paintEntries = performance.getEntriesByType('paint');\n        const firstPaint = paintEntries.find(entry => entry.name === 'first-paint');\n        return firstPaint ? firstPaint.startTime : null;\n    },\n    \n    // Obtener First Contentful Paint\n    _getFirstContentfulPaint() {\n        const paintEntries = performance.getEntriesByType('paint');\n        const fcp = paintEntries.find(entry => entry.name === 'first-contentful-paint');\n        return fcp ? fcp.startTime : null;\n    },\n    \n    // Medir Cumulative Layout Shift\n    async _measureCLS() {\n        return new Promise((resolve) => {\n            let clsScore = 0;\n            \n            if ('PerformanceObserver' in window) {\n                try {\n                    const observer = new PerformanceObserver((list) => {\n                        const entries = list.getEntries();\n                        entries.forEach(entry => {\n                            if (!entry.hadRecentInput) {\n                                clsScore += entry.value;\n                            }\n                        });\n                    });\n                    \n                    observer.observe({ entryTypes: ['layout-shift'] });\n                    \n                    // Observar por 2 segundos\n                    setTimeout(() => {\n                        observer.disconnect();\n                        resolve({ value: clsScore, rating: this._rateCLS(clsScore) });\n                    }, 2000);\n                } catch (error) {\n                    resolve({ value: 0, rating: 'unknown', error: error.message });\n                }\n            } else {\n                resolve({ value: 0, rating: 'unsupported' });\n            }\n        });\n    },\n    \n    // Test de velocidad de cache\n    async _testCacheSpeed() {\n        const iterations = 10;\n        const testKey = 'performance_test_' + Date.now();\n        const testData = { test: 'data', timestamp: Date.now() };\n        \n        // Test de escritura\n        const writeStart = performance.now();\n        for (let i = 0; i < iterations; i++) {\n            if (window.CacheManager) {\n                window.CacheManager.set(`${testKey}_${i}`, testData, 1, 'temp');\n            }\n        }\n        const writeTime = (performance.now() - writeStart) / iterations;\n        \n        // Test de lectura\n        const readStart = performance.now();\n        for (let i = 0; i < iterations; i++) {\n            if (window.CacheManager) {\n                window.CacheManager.get(`${testKey}_${i}`, 'temp');\n            }\n        }\n        const readTime = (performance.now() - readStart) / iterations;\n        \n        // Limpiar datos de test\n        for (let i = 0; i < iterations; i++) {\n            if (window.CacheManager) {\n                window.CacheManager.remove(`${testKey}_${i}`, 'temp');\n            }\n        }\n        \n        return {\n            writeTime: writeTime,\n            readTime: readTime,\n            averageTime: (writeTime + readTime) / 2\n        };\n    },\n    \n    // Test de endpoints cr√≠ticos\n    async _testCriticalEndpoints() {\n        const endpoints = [\n            { name: 'Products', url: '/api/products' },\n            { name: 'Categories', url: '/api/categories' },\n            { name: 'Health Check', url: '/api/health' }\n        ];\n        \n        const results = {};\n        \n        for (const endpoint of endpoints) {\n            try {\n                const startTime = performance.now();\n                const response = await fetch(endpoint.url);\n                const endTime = performance.now();\n                \n                results[endpoint.name] = {\n                    responseTime: endTime - startTime,\n                    status: response.status,\n                    ok: response.ok,\n                    size: response.headers.get('content-length') || 0\n                };\n            } catch (error) {\n                results[endpoint.name] = {\n                    responseTime: null,\n                    status: null,\n                    ok: false,\n                    error: error.message\n                };\n            }\n        }\n        \n        return results;\n    },\n    \n    // Analizar im√°genes en la p√°gina\n    _analyzePageImages() {\n        const images = document.querySelectorAll('img');\n        const analysis = {\n            totalImages: images.length,\n            lazyImages: 0,\n            optimizedImages: 0,\n            largeImages: 0,\n            totalEstimatedSize: 0\n        };\n        \n        images.forEach(img => {\n            if (img.hasAttribute('data-src') || img.loading === 'lazy') {\n                analysis.lazyImages++;\n            }\n            \n            if (img.hasAttribute('data-optimized')) {\n                analysis.optimizedImages++;\n            }\n            \n            if (img.naturalWidth > 800 || img.naturalHeight > 600) {\n                analysis.largeImages++;\n            }\n            \n            // Estimar tama√±o\n            analysis.totalEstimatedSize += (img.naturalWidth * img.naturalHeight * 3) / 8; // bytes estimados\n        });\n        \n        analysis.lazyPercentage = (analysis.lazyImages / analysis.totalImages * 100) || 0;\n        analysis.optimizedPercentage = (analysis.optimizedImages / analysis.totalImages * 100) || 0;\n        analysis.averageImageSize = analysis.totalEstimatedSize / analysis.totalImages / 1024; // KB\n        \n        return analysis;\n    },\n    \n    // Contar componentes React\n    _countReactComponents() {\n        // Heur√≠stica simple para contar componentes\n        const reactRoots = document.querySelectorAll('[data-reactroot]');\n        const componentElements = document.querySelectorAll('[data-react-component]');\n        \n        return {\n            roots: reactRoots.length,\n            components: componentElements.length,\n            estimatedTotal: Math.max(componentElements.length, 10) // m√≠nimo estimado\n        };\n    },\n    \n    // Medir tiempo de render\n    async _measureRenderTime() {\n        return new Promise((resolve) => {\n            const measurements = [];\n            const observer = new PerformanceObserver((list) => {\n                const entries = list.getEntries();\n                entries.forEach(entry => {\n                    if (entry.name.includes('react') || entry.name.includes('render')) {\n                        measurements.push(entry.duration);\n                    }\n                });\n            });\n            \n            observer.observe({ entryTypes: ['measure'] });\n            \n            setTimeout(() => {\n                observer.disconnect();\n                const average = measurements.length > 0 ? \n                    measurements.reduce((sum, time) => sum + time, 0) / measurements.length : 0;\n                resolve(average);\n            }, 2000);\n        });\n    },\n    \n    // Analizar re-renders\n    _analyzeReRenders() {\n        // Placeholder para an√°lisis de re-renders\n        // En una implementaci√≥n real, esto requerir√≠a instrumentaci√≥n espec√≠fica de React\n        return {\n            detected: false,\n            count: 0,\n            components: [],\n            note: 'An√°lisis de re-renders requiere instrumentaci√≥n espec√≠fica'\n        };\n    },\n    \n    // ========= EVALUACI√ìN Y RATING =========\n    \n    // Evaluar resultados contra umbrales\n    _evaluateResults(results, thresholds) {\n        const evaluation = {\n            raw: results,\n            scores: {},\n            overall: 'unknown'\n        };\n        \n        let totalScore = 0;\n        let scoreCount = 0;\n        \n        for (const [metric, value] of Object.entries(results)) {\n            if (thresholds[metric] && typeof value === 'number') {\n                const threshold = thresholds[metric];\n                let score;\n                \n                if (value <= threshold.good) {\n                    score = 'good';\n                } else if (value <= threshold.poor) {\n                    score = 'needs-improvement';\n                } else {\n                    score = 'poor';\n                }\n                \n                evaluation.scores[metric] = {\n                    value: value,\n                    score: score,\n                    threshold: threshold\n                };\n                \n                // Convertir a n√∫mero para promedio\n                const numScore = score === 'good' ? 3 : score === 'needs-improvement' ? 2 : 1;\n                totalScore += numScore;\n                scoreCount++;\n            }\n        }\n        \n        // Calcular score general\n        if (scoreCount > 0) {\n            const avgScore = totalScore / scoreCount;\n            evaluation.overall = avgScore >= 2.5 ? 'good' : avgScore >= 1.5 ? 'needs-improvement' : 'poor';\n        }\n        \n        return evaluation;\n    },\n    \n    // Rating para CLS\n    _rateCLS(value) {\n        if (value <= 0.1) return 'good';\n        if (value <= 0.25) return 'needs-improvement';\n        return 'poor';\n    },\n    \n    // ========= UTILIDADES =========\n    \n    // Obtener informaci√≥n de conexi√≥n\n    _getConnectionInfo() {\n        if ('connection' in navigator) {\n            return {\n                effectiveType: navigator.connection.effectiveType,\n                downlink: navigator.connection.downlink,\n                rtt: navigator.connection.rtt\n            };\n        }\n        return null;\n    },\n    \n    // Generar resumen de todos los tests\n    _generateSummary(tests) {\n        const summary = {\n            totalTests: Object.keys(tests).length,\n            passedTests: 0,\n            failedTests: 0,\n            overallScore: 'unknown',\n            criticalIssues: [],\n            recommendations: []\n        };\n        \n        let totalScore = 0;\n        let scoreCount = 0;\n        \n        for (const [testName, testResult] of Object.entries(tests)) {\n            if (testResult.overall === 'good') {\n                summary.passedTests++;\n                totalScore += 3;\n            } else if (testResult.overall === 'needs-improvement') {\n                totalScore += 2;\n            } else if (testResult.overall === 'poor') {\n                summary.failedTests++;\n                totalScore += 1;\n                summary.criticalIssues.push(`${testName}: ${testResult.overall}`);\n            }\n            scoreCount++;\n        }\n        \n        if (scoreCount > 0) {\n            const avgScore = totalScore / scoreCount;\n            summary.overallScore = avgScore >= 2.5 ? 'good' : avgScore >= 1.5 ? 'needs-improvement' : 'poor';\n        }\n        \n        // Generar recomendaciones basadas en resultados\n        summary.recommendations = this._generateRecommendations(tests);\n        \n        return summary;\n    },\n    \n    // Generar recomendaciones\n    _generateRecommendations(tests) {\n        const recommendations = [];\n        \n        // Recomendaciones basadas en Core Web Vitals\n        if (tests.coreWebVitals) {\n            const cwv = tests.coreWebVitals;\n            if (cwv.scores.lcp && cwv.scores.lcp.score !== 'good') {\n                recommendations.push('Optimizar LCP: Reducir tama√±o de im√°genes hero y mejorar tiempo de servidor');\n            }\n            if (cwv.scores.cls && cwv.scores.cls.score !== 'good') {\n                recommendations.push('Reducir CLS: Especificar dimensiones de im√°genes y evitar contenido din√°mico');\n            }\n        }\n        \n        // Recomendaciones de cach√©\n        if (tests.cachePerformance) {\n            const cache = tests.cachePerformance;\n            if (cache.scores.hitRate && cache.scores.hitRate.score !== 'good') {\n                recommendations.push('Mejorar estrategia de cach√©: Incrementar TTL para recursos est√°ticos');\n            }\n        }\n        \n        // Recomendaciones de API\n        if (tests.apiPerformance) {\n            const api = tests.apiPerformance;\n            if (api.scores.averageResponseTime && api.scores.averageResponseTime.score !== 'good') {\n                recommendations.push('Optimizar APIs: Implementar paginaci√≥n y reducir payload de respuestas');\n            }\n        }\n        \n        return recommendations;\n    },\n    \n    // ========= PERSISTENCIA Y REPORTES =========\n    \n    // Guardar resultados\n    _saveResults(results) {\n        try {\n            // Guardar en localStorage\n            const key = 'ventaspet_performance_results';\n            const existing = JSON.parse(localStorage.getItem(key) || '[]');\n            existing.push(results);\n            \n            // Mantener solo los √∫ltimos 10 resultados\n            if (existing.length > 10) {\n                existing.shift();\n            }\n            \n            localStorage.setItem(key, JSON.stringify(existing));\n            this.testResults.history = existing;\n            \n        } catch (error) {\n            console.warn('‚ö†Ô∏è No se pudieron guardar los resultados:', error);\n        }\n    },\n    \n    // Cargar baseline\n    loadBaseline() {\n        try {\n            const baseline = localStorage.getItem('ventaspet_performance_baseline');\n            if (baseline) {\n                this.testResults.baseline = JSON.parse(baseline);\n                console.log('üìä Baseline de rendimiento cargado');\n            }\n        } catch (error) {\n            console.warn('‚ö†Ô∏è No se pudo cargar baseline:', error);\n        }\n    },\n    \n    // Establecer baseline\n    setBaseline() {\n        if (this.testResults.current) {\n            this.testResults.baseline = this.testResults.current;\n            localStorage.setItem('ventaspet_performance_baseline', JSON.stringify(this.testResults.baseline));\n            console.log('‚úÖ Baseline establecido');\n        } else {\n            console.warn('‚ö†Ô∏è No hay resultados actuales para establecer baseline');\n        }\n    },\n    \n    // Mostrar reporte de tests\n    showTestReport() {\n        if (!this.testResults.current) {\n            console.log('‚ö†Ô∏è No hay resultados de tests para mostrar');\n            return;\n        }\n        \n        const results = this.testResults.current;\n        \n        console.log('\\nüß™ === REPORTE DE RENDIMIENTO VENTASPET ===');\n        console.log(`üìÖ Timestamp: ${results.timestamp}`);\n        console.log(`üåê URL: ${results.url}`);\n        console.log(`üì± Viewport: ${results.viewport.width}x${results.viewport.height}`);\n        \n        if (results.connection) {\n            console.log(`üì° Conexi√≥n: ${results.connection.effectiveType}`);\n        }\n        \n        console.log(`\\nüìä Resumen General:`);\n        console.log(`‚úÖ Tests pasados: ${results.summary.passedTests}`);\n        console.log(`‚ùå Tests fallidos: ${results.summary.failedTests}`);\n        console.log(`üéØ Score general: ${results.summary.overallScore}`);\n        \n        if (results.summary.criticalIssues.length > 0) {\n            console.log('\\nüö® Problemas cr√≠ticos:');\n            results.summary.criticalIssues.forEach(issue => {\n                console.log(`  ‚Ä¢ ${issue}`);\n            });\n        }\n        \n        if (results.summary.recommendations.length > 0) {\n            console.log('\\nüí° Recomendaciones:');\n            results.summary.recommendations.forEach(rec => {\n                console.log(`  ‚Ä¢ ${rec}`);\n            });\n        }\n        \n        console.log('\\n==========================================\\n');\n        \n        return results;\n    },\n    \n    // Comparar con baseline\n    compareWithBaseline() {\n        if (!this.testResults.current || !this.testResults.baseline) {\n            console.log('‚ö†Ô∏è Se requieren resultados actuales y baseline para comparar');\n            return null;\n        }\n        \n        const comparison = {\n            timestamp: new Date().toISOString(),\n            improvements: [],\n            regressions: [],\n            summary: {}\n        };\n        \n        // Comparar m√©tricas clave\n        const keyMetrics = ['pageLoadTime', 'domContentLoaded', 'lcp', 'fid', 'cls'];\n        \n        keyMetrics.forEach(metric => {\n            const currentValue = this._extractMetricValue(this.testResults.current, metric);\n            const baselineValue = this._extractMetricValue(this.testResults.baseline, metric);\n            \n            if (currentValue !== null && baselineValue !== null) {\n                const difference = currentValue - baselineValue;\n                const percentChange = (difference / baselineValue) * 100;\n                \n                if (Math.abs(percentChange) > 5) { // Solo cambios significativos\n                    const item = {\n                        metric,\n                        current: currentValue,\n                        baseline: baselineValue,\n                        difference,\n                        percentChange: percentChange.toFixed(1) + '%'\n                    };\n                    \n                    if (difference < 0) {\n                        comparison.improvements.push(item);\n                    } else {\n                        comparison.regressions.push(item);\n                    }\n                }\n            }\n        });\n        \n        console.log('\\nüìà === COMPARACI√ìN CON BASELINE ===');\n        \n        if (comparison.improvements.length > 0) {\n            console.log('‚úÖ Mejoras detectadas:');\n            comparison.improvements.forEach(item => {\n                console.log(`  ‚Ä¢ ${item.metric}: ${item.baseline} ‚Üí ${item.current} (${item.percentChange})`);\n            });\n        }\n        \n        if (comparison.regressions.length > 0) {\n            console.log('‚ùå Regresiones detectadas:');\n            comparison.regressions.forEach(item => {\n                console.log(`  ‚Ä¢ ${item.metric}: ${item.baseline} ‚Üí ${item.current} (${item.percentChange})`);\n            });\n        }\n        \n        if (comparison.improvements.length === 0 && comparison.regressions.length === 0) {\n            console.log('üìä No se detectaron cambios significativos');\n        }\n        \n        console.log('=====================================\\n');\n        \n        return comparison;\n    },\n    \n    // Extraer valor de m√©trica de resultados\n    _extractMetricValue(results, metric) {\n        // Buscar en diferentes secciones de los resultados\n        const sections = ['basicMetrics', 'coreWebVitals', 'cachePerformance', 'apiPerformance'];\n        \n        for (const section of sections) {\n            const sectionData = results.tests[section];\n            if (sectionData && sectionData.raw && sectionData.raw[metric] !== undefined) {\n                return sectionData.raw[metric];\n            }\n            \n            // Tambi√©n buscar en scores\n            if (sectionData && sectionData.scores && sectionData.scores[metric]) {\n                return sectionData.scores[metric].value;\n            }\n        }\n        \n        return null;\n    },\n    \n    // ========= CONFIGURACI√ìN AUTOM√ÅTICA =========\n    \n    // Configurar testing autom√°tico\n    setupAutomaticTesting() {\n        // Ejecutar tests ligeros cada 5 minutos\n        setInterval(() => {\n            if (!this.isRunning) {\n                this._runLightweightTest();\n            }\n        }, 5 * 60 * 1000);\n    },\n    \n    // Test ligero autom√°tico\n    async _runLightweightTest() {\n        try {\n            const basicMetrics = await this.testBasicMetrics();\n            const timestamp = new Date().toISOString();\n            \n            // Guardar m√©tricas b√°sicas\n            const lightResults = {\n                timestamp,\n                type: 'lightweight',\n                metrics: basicMetrics\n            };\n            \n            // Guardar en historial ligero\n            const key = 'ventaspet_light_metrics';\n            const existing = JSON.parse(localStorage.getItem(key) || '[]');\n            existing.push(lightResults);\n            \n            // Mantener solo las √∫ltimas 50 mediciones\n            if (existing.length > 50) {\n                existing.shift();\n            }\n            \n            localStorage.setItem(key, JSON.stringify(existing));\n            \n        } catch (error) {\n            console.warn('‚ö†Ô∏è Error en test autom√°tico:', error);\n        }\n    },\n    \n    // Configurar reportes autom√°ticos\n    setupAutomaticReporting() {\n        // Reporte autom√°tico cuando el rendimiento empeora significativamente\n        window.addEventListener('beforeunload', () => {\n            if (this.testResults.current && this.testResults.baseline) {\n                const comparison = this.compareWithBaseline();\n                if (comparison && comparison.regressions.length > 0) {\n                    console.warn('‚ö†Ô∏è Detectadas regresiones de rendimiento al cerrar p√°gina');\n                }\n            }\n        });\n    }\n};\n\n// Inicializar autom√°ticamente\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n        window.PerformanceTesting.init();\n    });\n} else {\n    window.PerformanceTesting.init();\n}\n\n// Exponer funciones globales para testing manual\nwindow.runPerformanceTests = () => window.PerformanceTesting.runFullTestSuite();\nwindow.showPerformanceReport = () => window.PerformanceTesting.showTestReport();\nwindow.setPerformanceBaseline = () => window.PerformanceTesting.setBaseline();\nwindow.comparePerformance = () => window.PerformanceTesting.compareWithBaseline();\n\nconsole.log('‚úÖ Performance Testing Suite cargado');\nconsole.log('üí° Usa runPerformanceTests() para ejecutar la suite completa');